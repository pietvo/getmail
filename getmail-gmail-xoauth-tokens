#!/usr/bin/env python2

#
# Copyright 2012 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
     # http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# Derived from oauth2.py (https://github.com/google/gmail-oauth2-tools).
# Heavily modified and rewritten by Stefan Krah.
# Gpg code added by Pieter van Oostrum <pieter@vanoostrum.org>


import os
import sys
import urllib
import json
import argparse
import time


class OAuth2(object):

    def __init__(self, token_data_path, gpg_key):
        self.token_data_path = token_data_path
        self.gpg_key = gpg_key

        if self.gpg_key:
            from subprocess import Popen, PIPE
            cmd = ['gpg', '-q', '-r', self.gpg_key, '-d', token_data_path]
            process = Popen(cmd, stdout=PIPE)
            out, err = process.communicate()
            self.data = json.loads(out)
            if err:
                print 'Error on decryption:', err
        else:
            with open(self.token_data_path) as f:
                self.data = json.load(f)

    def copy(self, *keys):
        data = {}
        for k in keys:
            data[k] = self.data[k]
        return data

    def query(self, params):
        lst = []
        for param in sorted(params.iteritems(), key=lambda x: x[0]):
            escaped = urllib.quote(param[1], safe='~-._')
            lst.append('%s=%s' % (param[0], escaped))
        return '&'.join(lst)

    def code_url(self):
        params = self.copy('scope', 'client_id', 'redirect_uri')
        params['response_type'] = 'code'
        return '%s?%s' % (self.data['auth_uri'], self.query(params))

    def get_response(self, url, params):
        encoded = urllib.urlencode(params)
        response = urllib.urlopen(url, encoded).read()
        return json.loads(response)

    def update_config(self, d):
        self.data['access_token'] = d['access_token']
        self.data['expires_at'] = time.time() + d['expires_in'] - 100

        refresh_token = d.get('refresh_token')
        if refresh_token is not None:
            self.data['refresh_token'] = refresh_token

        if self.gpg_key:
            from subprocess import Popen, PIPE
            json_str = json.dumps(self.data)
            cmd = ['gpg', '-q', '-r', self.gpg_key, '-e']
            process = Popen(cmd, stdin=PIPE, stdout=PIPE)
            out, err = process.communicate(json_str)
            if err:
                print 'Error on encryption:', err

            with open(self.token_data_path, "wb") as f:
                f.write(out)
        else:
            with open(self.token_data_path, "w") as f:
                json.dump(self.data, f)

    def init_tokens(self, code):
        params = self.copy('user', 'client_id', 'client_secret',
                           'redirect_uri')
        params['code'] = code
        params['grant_type'] = 'authorization_code'

        d = self.get_response(self.data['token_uri'], params)
        self.update_config(d)

    def refresh_tokens(self):
        params = self.copy('client_id', 'client_secret', 'refresh_token')
        params['grant_type'] = 'refresh_token'

        d = self.get_response(self.data['token_uri'], params)
        self.update_config(d)

    def token(self):
        if time.time() >= self.data.get('expires_at'):
            self.refresh_tokens()

        return self.data['access_token']


def check_gpg_key(value):
    "Check if gpg key is at least 8 chars hex"
    import re
    if len(value) >= 8 and re.match('[0-9a-fA-F]+$', value):
        return value
    raise argparse.ArgumentTypeError(
                "'{}' is not a valid gpg key - must be at least 8 hex characters".format(value))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--init", action="store_true", default=False,
                        help="initialize access and refresh tokens")
    parser.add_argument('tokenfile', metavar='<token data file path>',
                        help="location of the token data file")
    parser.add_argument('--gpg', metavar='<gpg key id>', dest='gpg_key', type=check_gpg_key,
                        help="A gpg key ID used for encryption of the token data file")

    args = parser.parse_args()
    auth = OAuth2(args.tokenfile, args.gpg_key)

    if args.init:
        print "Visit this url to obtain a verification code:"
        print "    %s\n" % auth.code_url()

        code = raw_input("Enter verification code: ")
        response = auth.init_tokens(code)
    else:
        sys.stdout.write("%s" % auth.token())

    sys.exit(0)
